#summary This document briefly describes how the GRTFramework is used
#labels Featured,Phase-Implementation

= Introduction =

The GRTFramework is built in such a way that developers can easily develop sophisticated code for their robots, without the hassles of execution management or pseudokernels. Understanding how to use it is mostly a function of figuring out what to ignore, and where your code goes! 

= Details =

All user code in the GRTFramework falls under either Mechanism, Controller, or MainRobot. For example of these explore the classes already contained under {{{ com.grt192.controller.* and com.grt192.mechanism.* }}}

== Mechanisms ==

A Mechanism is a _model_ of a robot mechanism, containing all the actuators(motors, servos, pneumatics) and sensors that are a part of that mechanism's function. Examples include: Arms, Shooting mechanisms, Elevators, and Wheeled-bases.

A mechanism is an object--it is not executed continuously, but it has methods that allow for specific actions to take space. 

=== Usage ===

For each of the mechanisms on your robot:
  # Create a class that {{{ extends Mechanism }}}
  # Create a constructor for that class with parameters of ALL the electronic components you will use:
{{{
public GRTRobotBase(GRTDriveTrain dt, GRTGyro gy,
            GRTAccelerometer ax) {
}}}
  # For each of the electronic components, start it and then add it to the mechanism as either a Sensor or an Actuator:
{{{
        gy.start();
        ax.start();
        dt.start();
        addActuator("DriveTrain", dt);
        addSensor("Gyro", gy);
        addSensor("Accelerometer", ax);
}}}
  # Write high-level methods associated with that mechanism--for robotbase that means driving & turning commands(driveForward, turnLeft..etc)

=== A Word About Writing "High-Level" Methods ===
First, to get your actuators out from your mechanism, just call 
{{{
this.getActuator("actuatorName");
}}}

Ok so there's one trick you should know about actually using Actuators (GRTVictor, GRTServo, GRTJaguar..etc)
You can't call GRTJaguar.setSpeed(XX). Instead what you need to do is send it a command, which it will execute as it is available. 
{{{
   getActuator("Victor").enqueueCommand(new Command(speed));
}}}
You can issue as many commands as you like, whenever you like, and as long as an actuator is not suspended or disabled, it'll do them. 

== Controllers ==

Once your mechanisms are written, all you need to do is write the logic that controls them...This logic sits in Controllers, which are independently running(Threads) that exercise control over a mechanism or many mechanisms
To do this:
  # Create a class {{{ extends Controller }}}
  # Create a constructor for that class with parameters of ALL the mechanisms you will use, and "addMechanism" them:
{{{
    public DriveController(GRTRobotBase rb, GRTDriverStation ds) {
        super();
        addMechanism("DriverStation", ds);
        addMechanism("RobotBase", rb);
    }
}}}
  # Write a run() method that contains your logic!

=== A Word About StepControllers ===
A StepController is a variant on the controller system, where instead of populating a run() method with an inifinite loop, you can simply write an act() method, that is executed repeatedly inside a loop that happens behind the scenes. This allows for easy statemachine code(each act call executes a different piece of code based on the state), and our code behind the scenes takes care of thread execution safety and cleanup.

== MainRobot ==
This is really really simple even though it looks super long. 
A MainRobot houses the controller and mechanism instances, and instantiates all of them on VM start. see the included example for more information.